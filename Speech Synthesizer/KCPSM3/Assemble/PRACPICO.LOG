KCPSM3 Assembler log file for program 'pracpico.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
22Jul2021-22:32:42

 Addr Code

 000                               ;**************************************************************************************
 000                               ; Port definitions
 000                               ;**************************************************************************************
 000                               ;
 000                               ;
 000                               ;
 000                               CONSTANT LED_port, 80              ;8 simple LEDs. Is an OUTPUT port. for LED[9:2]
 000                               CONSTANT DATA_IN_PORT, 00          ;input data port. this is an INPUT port.
 000                               CONSTANT LED_0, 40
 000                               CONSTANT ISR_preserve_s0, 00       ;Preserve s0 contents during ISR
 000                               CONSTANT ISR_preserve_s1, 01       ;Preserve s1 contents during ISR
 000                               CONSTANT ISR_preserve_s2, 02       ;Preserve s2 contents during ISR
 000                               CONSTANT ISR_preserve_s3, 03       ;Preserve s3 contents during ISR
 000                               CONSTANT ISR_preserve_s4, 04
 000                               CONSTANT ISR_preserve_s5, 05
 000                               CONSTANT save_s2, 07
 000                               CONSTANT save_s3, 08
 000                               CONSTANT save_s1, 06
 000                               ;
 000                               CONSTANT LED_pattern, 04           ;remember state of LEDs (8-bit counter in this case)
 000                               ;
 000                               ;**************************************************************************************
 000                               ; Useful data constants
 000                               ;**************************************************************************************
 000                               ;
 000                               ;
 000                               ; Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                               ; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
 000                               ; calculation highly predictable. The '6' in the following equation even allows for
 000                               ; 'CALL delay_1us' instruction in the initiating code.
 000                               ;
 000                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                               ;
 000                               ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
 000                               ; For clock rates below 10MHz the value of 1 must be used and the operation will
 000                               ; become lower than intended. Interrupts may effect the timing of software based
 000                               ; delays.
 000                               ;
 000                               CONSTANT delay_1us_constant, 05
 000                               ;
 000                               ;
 000                               ;
 000                               ;**************************************************************************************
 000                               ; Initialise the system
 000                               ;**************************************************************************************
 000                               ;
 000  00000            cold_start: LOAD s0, 00
 001  2E004                        STORE s0, LED_pattern[04]
 002  2C080                        OUTPUT s0, LED_port[80]
 003  3C001                        ENABLE INTERRUPT                   ;now interrupts are on
 004                               ;*******************PART1*******************;
 004                 main_program: 
 004  00601                        LOAD s6, 01                        ;mov s1,#1
 005  2C640                        OUTPUT s6, LED_0[40]               ;now the LED0 is on
 006  3001E                        CALL delay_1s[01E]                 ;wait 1 second
 007  00600                        LOAD s6, 00                        ;mov s1,#0
 008  2C640                        OUTPUT s6, LED_0[40]               ;now the LED0 is off
 009  3001E                        CALL delay_1s[01E]                 ;wait 1 second
 00A  34004                        JUMP main_program[004]
 00B                               ;**************************************************************************************
 00B                               ; Software delay routines
 00B                               ;**************************************************************************************
 00B                               ;
 00B                               ; Delay of 1us.
 00B                               ;
 00B                               ; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
 00B                               ; instruction executes in 2 clock cycles making the calculation highly predictable.
 00B                               ; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
 00B                               ; in the initiating code. Interrupts may effect software derived delays.
 00B                               ;
 00B                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 00B                               ;
 00B                               ; Registers used s0
 00B  00005             delay_1us: LOAD s0, delay_1us_constant[05]
 00C  1C001              wait_1us: SUB s0, 01
 00D  3540C                        JUMP NZ, wait_1us[00C]
 00E  2A000                        RETURN
 00F                               ;
 00F                               ; Delay of 40us.
 00F                               ;
 00F                               ; Registers used s0, s1
 00F                               ;
 00F  00128            delay_40us: LOAD s1, 28                        ;40 x 1us = 40us
 010  3000B             wait_40us: CALL delay_1us[00B]
 011  1C101                        SUB s1, 01
 012  35410                        JUMP NZ, wait_40us[010]
 013  2A000                        RETURN
 014                               ;
 014                               ;
 014                               ; Delay of 1ms.
 014                               ;
 014                               ; Registers used s0, s1, s2
 014                               ;
 014  00219             delay_1ms: LOAD s2, 19                        ;25 x 40us = 1ms
 015  3000F              wait_1ms: CALL delay_40us[00F]
 016  1C201                        SUB s2, 01
 017  35415                        JUMP NZ, wait_1ms[015]
 018  2A000                        RETURN
 019                               ;
 019                               ; Delay of 20ms.
 019                               ;
 019                               ; Delay of 20ms used during initialisation.
 019                               ;
 019                               ; Registers used s0, s1, s2, s3
 019                               ;
 019  00314            delay_20ms: LOAD s3, 14                        ;20 x 1ms = 20ms
 01A  30014             wait_20ms: CALL delay_1ms[014]
 01B  1C301                        SUB s3, 01
 01C  3541A                        JUMP NZ, wait_20ms[01A]
 01D  2A000                        RETURN
 01E                               ;
 01E                               ; Delay of approximately 1 second.
 01E                               ;
 01E                               ; Registers used s0, s1, s2, s3, s4
 01E                               ;
 01E  00432              delay_1s: LOAD s4, 32                        ;50 x 20ms = 1000ms
 01F  30019               wait_1s: CALL delay_20ms[019]
 020  1C401                        SUB s4, 01
 021  3541F                        JUMP NZ, wait_1s[01F]
 022  2A000                        RETURN                             ;from pracPICO.psm
 023                               ;*******************PART2***************************;
 023                               ;some important comments:
 023                               ;we need to read the data and then  s1 counter s2 sum
 023                          ISR: 
 023  2E000                        STORE s0, ISR_preserve_s0[00]      ;data
 024  2E101                        STORE s1, ISR_preserve_s1[01]      ;let's use it as a counter
 025  2E202                        STORE s2, ISR_preserve_s2[02]      ;let's use it as sum1
 026  2E303                        STORE s3, ISR_preserve_s3[03]      ;let's use it as save_s3
 027  2E404                        STORE s4, ISR_preserve_s4[04]      ;let's use it as unimportant sum
 028  2E505                        STORE s5, ISR_preserve_s5[05]      ;this is the output of led
 029  06106                        FETCH s1, save_s1[06]              ; reload the values of this
 02A  06207                        FETCH s2, save_s2[07]
 02B  06308                        FETCH s3, save_s3[08]
 02C  04000                        INPUT s0, DATA_IN_PORT[00]         ; s0 gets the data
 02D  14080                        COMPARE s0, 80                     ; see if the msb is 1 which means negative
 02E  35C3F                        JUMP NC, negative_to_positive[03F]
 02F                    continue1: 
 02F                               ;now  256 times wait
 02F  19100                        ADD s1, s0                         ;  now add this save_s1
 030  3583D                        JUMP C, increment_LED[03D]
 031                 counter_loop: 
 031  18301                        ADD s3, 01                         ;will finish it after it reaches to FF
 032  35842                        JUMP C, got_256[042]
 033  2E106                        STORE s1, save_s1[06]              ;save them to memory
 034  2E207                        STORE s2, save_s2[07]
 035  2E308                        STORE s3, save_s3[08]
 036  06000                        FETCH s0, ISR_preserve_s0[00]      ;let's return them to the stack
 037  06101                        FETCH s1, ISR_preserve_s1[01]
 038  06202                        FETCH s2, ISR_preserve_s2[02]
 039  06303                        FETCH s3, ISR_preserve_s3[03]
 03A  06404                        FETCH s4, ISR_preserve_s4[04]
 03B  06505                        FETCH s5, ISR_preserve_s5[05]
 03C  38001                        RETURNI ENABLE
 03D                increment_LED: 
 03D  18201                        ADD s2, 01                         ;save_s3 is incrementing by 1
 03E  34031                        JUMP counter_loop[031]
 03F         negative_to_positive: 
 03F  0E0FF                        XOR s0, FF
 040  18001                        ADD s0, 01                         ;now we convert negative to positive
 041  3402F                        JUMP continue1[02F]
 042                      got_256: ;here we will compare the value of save_s3 then output it to LEDs
 042                               ;let's say we got 5 = 00000101 then we need to get xxx00000
 042  20206                        SL0 s2
 043  35C47                        JUMP NC, six[047]
 044  001FF                        LOAD s1, FF                        ;LED2
 045  2C180                        OUTPUT s1, LED_port[80]
 046  3406F                        JUMP END[06F]
 047                          six: 
 047  20206                        SL0 s2
 048  35C4C                        JUMP NC, five[04C]
 049  001FE                        LOAD s1, FE
 04A  2C180                        OUTPUT s1, LED_port[80]
 04B  3406F                        JUMP END[06F]
 04C                         five: 
 04C  20206                        SL0 s2
 04D  35C51                        JUMP NC, four[051]
 04E  001FC                        LOAD s1, FC
 04F  2C180                        OUTPUT s1, LED_port[80]
 050  3406F                        JUMP END[06F]
 051                         four: 
 051  20206                        SL0 s2
 052  35C56                        JUMP NC, three[056]
 053  001F8                        LOAD s1, F8
 054  2C180                        OUTPUT s1, LED_port[80]
 055  3406F                        JUMP END[06F]
 056                        three: 
 056  20206                        SL0 s2
 057  35C5B                        JUMP NC, two[05B]
 058  001F0                        LOAD s1, F0
 059  2C180                        OUTPUT s1, LED_port[80]
 05A  3406F                        JUMP END[06F]
 05B                          two: 
 05B  20206                        SL0 s2
 05C  35C60                        JUMP NC, one[060]
 05D  001E0                        LOAD s1, E0
 05E  2C180                        OUTPUT s1, LED_port[80]
 05F  3406F                        JUMP END[06F]
 060                          one: 
 060  20206                        SL0 s2
 061  35C65                        JUMP NC, zero[065]
 062  001C0                        LOAD s1, C0
 063  2C180                        OUTPUT s1, LED_port[80]
 064  3406F                        JUMP END[06F]
 065                         zero: 
 065  20206                        SL0 s2
 066  35C6A                        JUMP NC, real_zero[06A]
 067  00180                        LOAD s1, 80
 068  2C180                        OUTPUT s1, LED_port[80]
 069  3406F                        JUMP END[06F]
 06A                    real_zero: 
 06A  20206                        SL0 s2
 06B  35C6F                        JUMP NC, END[06F]
 06C  00100                        LOAD s1, 00
 06D  2C180                        OUTPUT s1, LED_port[80]
 06E  3406F                        JUMP END[06F]
 06F                          END: 
 06F  00100                        LOAD s1, 00                        ; reset
 070  00200                        LOAD s2, 00
 071  00300                        LOAD s3, 00
 072  2E106                        STORE s1, save_s1[06]              ; save to memory
 073  2E207                        STORE s2, save_s2[07]
 074  2E308                        STORE s3, save_s3[08]
 075  06000                        FETCH s0, ISR_preserve_s0[00]      ;let's return them to the stack
 076  06101                        FETCH s1, ISR_preserve_s1[01]
 077  06202                        FETCH s2, ISR_preserve_s2[02]
 078  06303                        FETCH s3, ISR_preserve_s3[03]
 079  06404                        FETCH s4, ISR_preserve_s4[04]
 07A  06505                        FETCH s5, ISR_preserve_s5[05]
 07B  38001                        RETURNI ENABLE
 07C                               ;**************************************************************************************
 07C                               ; Interrupt Vector
 07C                               ;**************************************************************************************
 07C                               ;
 3FF                               ADDRESS 3FF                        ;for interrupt
 3FF  34023                        JUMP ISR[023]                      ;for interrupt
 3FF                               ;
 3FF                               ;
